/* Documentação: http://www2.cs.tum.edu/projects/cup/ */
import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;

import myPackage.Programa; // classe que vai guardar os blocos de ação e cenários, pra gerar o código final

parser code {:
    // conectar esse parser ao scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }

    String teste = "teste";
    int count = 0;
    int lines = 1;

    boolean debug = false;
    boolean error = false;
    String descricao_erro = "";
    
    // tabela de símbolos
    java.util.Map<String, Integer> simbolos = new java.util.HashMap<String, Integer>();
:}

/* conectar esse parser ao scanner! */
init with {:  :};
scan with {:
    // debug 
    Symbol token = s.next_token();
    // String token_str = token.toString();
    
    // String token_str = token.value.toString();
    // String token_str = token.value.toString();

    // se token.value for null, então token_str = token.toString()
    String token_str = token.value == null ? token.toString() : token.value.toString();

    System.out.println("Token: " + token_str);
    System.out.println("Error: " + error);

    if(error){
        error = false;
       System.out.println("---"+descricao_erro+"---");
    }
    // return s.next_token(); 
    return token; 
:};

/* Terminals */
terminal LBRACE, RBRACE;             // { }
terminal LBRACKET, RBRACKET;         // [ ]
terminal EQUALS;                     // =
terminal SEMICOLON;                  // ;
terminal LPAREN, RPAREN;             // ( )
terminal String STRING_LITERAL;     // "qualquer coisa"
terminal String IDENTIFICADOR;      // identificador = "valor"
terminal String BLOCK;              // definicao_de_{block}

terminal NOME, BLOCK_TYPE_ACOES, BLOCK_TYPE_RESULTADOS, BLOCK_TYPE_CENARIOS, BLOCK_TYPE_TESTE, BLOCK_TYPE_CONFIGURACAO;

terminal LINHA, IDENTIFICADOR_ACAO_TIPO, ACOES_CENARIO, IDENTIFICADOR_ACAO, IDENTIFICADOR_BROWSER, IDENTIFICADOR_TESTE, IDENTIFICADOR_AMBIENTE, IDENTIFICADOR_CENARIOS_TESTE, IDENTIFICADOR_URL_BASE, IDENTIFICADOR_CENARIO, IDENTIFICADOR_RESULTADO, IDENTIFICADOR_CONFIGURACAO_TESTE, DADOS_ENTRADA_CENARIO, RESULTADOS_ESPERADOS_CENARIO;

/* Non terminals para blocos principais */
non terminal input;
non terminal Programa programa;
non terminal HashMap<String, String> chave_valor;
non terminal List<HashMap<String, String>> chaves_valor;
//non terminal bloco_de_configuração;
non terminal bloco_generico;
non terminal inicio;

/* Gramática */

inicio ::= inicio input:e
    | input:e;


// TESTE => Esse aqui é para armazenar um conjunto de chave valores. A gente precisa de um Blocks.
// input ::= LBRACKET chaves_valor:cv RBRACKET
//     {: 
//         System.out.println("Parsed input: " + cv);
//         RESULT = cv;
//     :}
// ;


// Adicionar agora o bloco de configuração ao input também
input ::= LBRACKET bloco_generico:cv RBRACKET
    {: 
        System.out.println("Parsed input: " + cv);
        RESULT = cv;
    :}
    | LBRACKET chaves_valor:cv RBRACKET
    {: 
        System.out.println("Parsed input: " + cv);
        RESULT = cv;
    :}
;


// INICIO BLOCO DE CONFIGURAÇÃO
// EXEMPLO:
// definicao_de_configuracao {
//     ambiente = "teste";
//     url_base = "https://www.example.com/";
//     browser = "chrome";
// }

bloco_generico ::= BLOCK:bloco LBRACE chaves_valor:cv RBRACE
    {: 
        System.out.println("Bloco: " + bloco + ", Chaves e valores: " + cv);

        // Converte a lista de HashMaps em um único HashMap
        HashMap<String, String> result = new HashMap<>();
        for (HashMap<String, String> map : cv) {
            result.putAll(map); // Adiciona todas as entradas de cada HashMap na lista
        }

        // Adiciona o bloco como chave especial, se necessário
        result.put("block_type", bloco);

        RESULT = result;
    :}
;


// chave valor.
// identificador = "valor";
chave_valor ::= IDENTIFICADOR:chave EQUALS STRING_LITERAL:valor SEMICOLON
    {: 
        HashMap<String, String> map = new HashMap<>();
        map.put(chave, valor);
        System.out.println("Chave: " + chave + ", Valor: " + valor);
        RESULT = map;
    :}
;

// Chave valor recursivo, armazenando um array de hashmaps ou nao
chaves_valor ::= chave_valor:cv
    {: 
        System.out.println("Chave: " + cv.keySet().toArray()[0] + ", Valor: " + cv.values().toArray()[0]);
        List<HashMap<String, String>> list = new ArrayList<>();
        list.add(cv);
        RESULT = list;
    :}
    | chaves_valor:cv chave_valor:cv2
    {: 
        System.out.println("Chave: " + cv2.keySet().toArray()[0] + ", Valor: " + cv2.values().toArray()[0]);
        List<HashMap<String, String>> list = new ArrayList<>();
        list.addAll(cv);
        list.add(cv2);
        RESULT = list;
    :}
;
