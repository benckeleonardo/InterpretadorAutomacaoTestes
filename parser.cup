/* Documentação: http://www2.cs.tum.edu/projects/cup/ */
import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;

import myPackage.Programa; // classe que vai guardar os blocos de ação e cenários, pra gerar o código final

parser code {:
    // conectar esse parser ao scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }

    String teste = "teste";
    int count = 0;
    int lines = 1;

    boolean debug = false;
    boolean error = false;
    String descricao_erro = "";
    
    // tabela de símbolos
    java.util.Map<String, Integer> simbolos = new java.util.HashMap<String, Integer>();
:}

/* conectar esse parser ao scanner! */
init with {:  :};
scan with {:
    Symbol token = s.next_token();

    // se token.value for null, então token_str = token.toString()
    String token_str = token.value == null ? token.toString() : token.value.toString();

    System.out.println("Token: " + token_str + " - " + token.sym);
    System.out.println("Erro encontrado: " + error);

    if(error){
        error = false;
       System.out.println("---"+descricao_erro+"---");
    }
    // return s.next_token(); 
    return token; 
:};

/* Terminais */
terminal LBRACE, RBRACE;            // { }
terminal LBRACKET, RBRACKET;        // [ ]
terminal EQUALS;                    // =
terminal SEMICOLON;                 // ;
terminal LPAREN, RPAREN;            // ( )
terminal String STRING;             // "qualquer coisa"
terminal String IDENTIFICADOR;      // identificador = "valor"
terminal String NUMERAL;            // 123
terminal String BLOCO;              // definicao_de_{block}

terminal NOVA_LINHA;

/* Não terminais */
non terminal input;
non terminal Programa programa;

/* Uma lista de pares chave-valor */
non terminal List<HashMap<String, String>> chaves_valor;

/* Conteúdo de um bloco (misto: chave-valor ou outros blocos) */
non terminal List<Object> conteudo_bloco_aninhado;

/* Estruturas para armazenar dados */
non terminal HashMap<String, Object> bloco_generico;         // Blocos genéricos com chaves e valores ou outros blocos
non terminal HashMap<String, String> chave_valor;            // Um par chave-valor
non terminal List<Object> chaves_valor_ou_blocos;            // Lista combinada de chave-valor e blocos
non terminal List<HashMap<String, Object>> blocos_genericos; // Lista de bloco genérico

non terminal inicio;

/* Gramática */
inicio ::= LBRACKET blocos_genericos:blocos RBRACKET
    {: 
        System.out.println("Programa final com blocos: " + blocos);
        RESULT = blocos; 
    :}
;

// Adicionar agora o bloco de configuração ao input também
input ::= LBRACKET blocos_genericos:bl RBRACKET
    {: 
        System.out.println("Parsed multiple blocks: " + bl);
        RESULT = bl;
    :}
;


/* Bloco genérico */
bloco_generico ::= BLOCO:bloco LBRACE chaves_valor_ou_blocos:conteudo RBRACE
    {: 
        HashMap<String, Object> map = new HashMap<>();
        map.put("block_type", bloco);
        map.put("content", conteudo);
        RESULT = map;
    :}
;

/* Conteúdo de um bloco (misto) */
conteudo_bloco_aninhado ::= chave_valor:cv
    {: 
        List<Object> conteudo = new ArrayList<>();
        conteudo.add(cv); // Adiciona um par chave-valor
        RESULT = conteudo;
    :}
    | conteudo_bloco_aninhado:conteudo chave_valor:cv
    {: 
        conteudo.add(cv); // Adiciona mais pares chave-valor
        RESULT = conteudo;
    :}
    | bloco_generico:bg
    {: 
        List<Object> conteudo = new ArrayList<>();
        conteudo.add(bg); // Adiciona um bloco
        RESULT = conteudo;
    :}
    | conteudo_bloco_aninhado:conteudo bloco_generico:bg
    {: 
        conteudo.add(bg); // Adiciona mais blocos
        RESULT = conteudo;
    :}
;

// Conteúdo de um bloco pode ser chave-valor ou outros blocos
chaves_valor_ou_blocos ::= chave_valor:cv
    {: 
        List<Object> list = new ArrayList<>();
        list.add(cv);
        RESULT = list;
    :}
    | bloco_generico:bg
    {: 
        List<Object> list = new ArrayList<>();
        list.add(bg);
        RESULT = list;
    :}
    | chaves_valor_ou_blocos:cvb chave_valor:cv
    {: 
        List<Object> list = new ArrayList<>(cvb);
        list.add(cv);
        RESULT = list;
    :}
    | chaves_valor_ou_blocos:cvb bloco_generico:bg
    {: 
        List<Object> list = new ArrayList<>(cvb);
        list.add(bg);
        RESULT = list;
    :}
;

blocos_genericos ::= bloco_generico:bloco
    {: 
        List<HashMap<String, Object>> list = new ArrayList<>();
        list.add(bloco);
        RESULT = list;
    :}
    | blocos_genericos:blocos bloco_generico:bloco
    {: 
        List<HashMap<String, Object>> list = new ArrayList<>(blocos);
        list.add(bloco);
        RESULT = list;
    :}
;


// chave valor.
// identificador = "valor";
// 123 = "valor";
chave_valor ::= IDENTIFICADOR:chave EQUALS STRING:valor SEMICOLON
    {: 
        HashMap<String, String> map = new HashMap<>();
        map.put(chave, valor);
        System.out.println("Chave: " + chave + ", Valor: " + valor);
        RESULT = map;
    :}
    | NUMERAL:chave EQUALS STRING:valor SEMICOLON
    {: 
        HashMap<String, String> map = new HashMap<>();
        map.put(String.valueOf(chave), valor); // Converta o NUMERAL para String
        System.out.println("Chave (numérica): " + chave + ", Valor: " + valor);
        RESULT = map;
    :}
;

// Chave valor recursivo, armazenando um array de hashmaps ou nao
chaves_valor ::= chave_valor:cv
    {: 
        System.out.println("Chave: " + cv.keySet().toArray()[0] + ", Valor: " + cv.values().toArray()[0]);
        List<HashMap<String, String>> list = new ArrayList<>();
        list.add(cv);
        RESULT = list;
    :}
    | chaves_valor:cv chave_valor:cv2
    {: 
        System.out.println("Chave: " + cv2.keySet().toArray()[0] + ", Valor: " + cv2.values().toArray()[0]);
        List<HashMap<String, String>> list = new ArrayList<>();
        list.addAll(cv);
        list.add(cv2);
        RESULT = list;
    :}
;