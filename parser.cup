/* Documentação: http://www2.cs.tum.edu/projects/cup/ */
import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;

import myPackage.Programa; // classe que vai guardar os blocos de ação e cenários, pra gerar o código final

parser code {:
    // conectar esse parser ao scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }

    String teste = "teste";
    int count = 0;
    int lines = 1;

    boolean debug = false;
    boolean error = false;
    String descricao_erro = "";
    
    // tabela de símbolos
    java.util.Map<String, Integer> simbolos = new java.util.HashMap<String, Integer>();
:}

/* conectar esse parser ao scanner! */
init with {:  :};
scan with {:
    // debug 
    Symbol token = s.next_token();
    // String token_str = token.toString();
    
    // String token_str = token.value.toString();
    // String token_str = token.value.toString();

    // se token.value for null, então token_str = token.toString()
    String token_str = token.value == null ? token.toString() : token.value.toString();

    System.out.println("Token: " + token_str + " - " + token.sym);
    System.out.println("Error: " + error);

    if(error){
        error = false;
       System.out.println("---"+descricao_erro+"---");
    }
    // return s.next_token(); 
    return token; 
:};

/* Terminals */
terminal LBRACE, RBRACE;             // { }
terminal LBRACKET, RBRACKET;         // [ ]
terminal EQUALS;                     // =
terminal SEMICOLON;                  // ;
terminal LPAREN, RPAREN;             // ( )
terminal String STRING_LITERAL;     // "qualquer coisa"
terminal String IDENTIFICADOR;      // identificador = "valor"
terminal String BLOCK;              // definicao_de_{block}

terminal NOME, BLOCK_TYPE_ACOES, BLOCK_TYPE_RESULTADOS, BLOCK_TYPE_CENARIOS, BLOCK_TYPE_TESTE, BLOCK_TYPE_CONFIGURACAO;

terminal LINHA, IDENTIFICADOR_ACAO_TIPO, ACOES_CENARIO, IDENTIFICADOR_ACAO, IDENTIFICADOR_BROWSER, IDENTIFICADOR_TESTE, IDENTIFICADOR_AMBIENTE, IDENTIFICADOR_CENARIOS_TESTE, IDENTIFICADOR_URL_BASE, IDENTIFICADOR_CENARIO, IDENTIFICADOR_RESULTADO, IDENTIFICADOR_CONFIGURACAO_TESTE, DADOS_ENTRADA_CENARIO, RESULTADOS_ESPERADOS_CENARIO;

/* Non terminals para blocos principais */
non terminal input;
non terminal Programa programa;

/* Um par chave-valor simples */
// non terminal HashMap<String, String> chave_valor;

/* Uma lista de pares chave-valor */
non terminal List<HashMap<String, String>> chaves_valor;

/* Um bloco genérico com conteúdo misto */
// non terminal HashMap<String, Object> bloco_generico;

/* Conteúdo de um bloco (misto: chave-valor ou outros blocos) */
non terminal List<Object> conteudo_bloco_aninhado;

/* Lista de blocos aninhados ou genéricos */
non terminal List<HashMap<String, Object>> blocos_genericos_ou_aninhados;

/* Estruturas para armazenar dados */
non terminal HashMap<String, Object> bloco_generico;   // Blocos genéricos com chaves e valores ou outros blocos
non terminal HashMap<String, String> chave_valor;      // Um par chave-valor
non terminal List<Object> chaves_valor_ou_blocos;      // Lista combinada de chave-valor e blocos
non terminal List<HashMap<String, Object>> blocos_genericos; // Lista de blocos

non terminal HashMap<String, String> acao;


non terminal inicio;

/* Gramática */

inicio ::= LBRACKET blocos_genericos:blocos RBRACKET
    {: 
        System.out.println("Programa final com blocos: " + blocos);
        RESULT = blocos; 
    :}
;


// TESTE => Esse aqui é para armazenar um conjunto de chave valores. A gente precisa de um Blocks.
// input ::= LBRACKET chaves_valor:cv RBRACKET
//     {: 
//         System.out.println("Parsed input: " + cv);
//         RESULT = cv;
//     :}
// ;


// Adicionar agora o bloco de configuração ao input também
input ::= LBRACKET blocos_genericos:bl RBRACKET
    {: 
        System.out.println("Parsed multiple blocks: " + bl);
        RESULT = bl;
    :}
;

// INICIO BLOCO DE CONFIGURAÇÃO
// EXEMPLO:
// definicao_de_configuracao {
//     ambiente = "teste";
//     url_base = "https://www.example.com/";
//     browser = "chrome";
// }

/* Bloco genérico */
// Bloco genérico com suporte para aninhamento
bloco_generico ::= BLOCK:bloco LBRACE chaves_valor_ou_blocos:conteudo RBRACE
    {: 
        HashMap<String, Object> map = new HashMap<>();
        map.put("block_type", bloco);
        map.put("content", conteudo);
        RESULT = map;
    :}
;

/* Conteúdo de um bloco (misto) */
conteudo_bloco_aninhado ::= chave_valor:cv
    {: 
        List<Object> conteudo = new ArrayList<>();
        conteudo.add(cv); // Adiciona um par chave-valor
        RESULT = conteudo;
    :}
    | conteudo_bloco_aninhado:conteudo chave_valor:cv
    {: 
        conteudo.add(cv); // Adiciona mais pares chave-valor
        RESULT = conteudo;
    :}
    | bloco_generico:bg
    {: 
        List<Object> conteudo = new ArrayList<>();
        conteudo.add(bg); // Adiciona um bloco
        RESULT = conteudo;
    :}
    | conteudo_bloco_aninhado:conteudo bloco_generico:bg
    {: 
        conteudo.add(bg); // Adiciona mais blocos
        RESULT = conteudo;
    :}
;

// Conteúdo de um bloco pode ser chave-valor ou outros blocos
chaves_valor_ou_blocos ::= chave_valor:cv
    {: 
        List<Object> list = new ArrayList<>();
        list.add(cv);
        RESULT = list;
    :}
    | bloco_generico:bg
    {: 
        List<Object> list = new ArrayList<>();
        list.add(bg);
        RESULT = list;
    :}
    | chaves_valor_ou_blocos:cvb chave_valor:cv
    {: 
        List<Object> list = new ArrayList<>(cvb);
        list.add(cv);
        RESULT = list;
    :}
    | chaves_valor_ou_blocos:cvb bloco_generico:bg
    {: 
        List<Object> list = new ArrayList<>(cvb);
        list.add(bg);
        RESULT = list;
    :}
;

blocos_genericos ::= bloco_generico:bloco
    {: 
        List<HashMap<String, Object>> list = new ArrayList<>();
        list.add(bloco);
        RESULT = list;
    :}
    | blocos_genericos:blocos bloco_generico:bloco
    {: 
        List<HashMap<String, Object>> list = new ArrayList<>(blocos);
        list.add(bloco);
        RESULT = list;
    :}
;


// chave valor.
// identificador = "valor";
chave_valor ::= IDENTIFICADOR:chave EQUALS STRING_LITERAL:valor SEMICOLON
    {: 
        HashMap<String, String> map = new HashMap<>();
        map.put(chave, valor);
        System.out.println("Chave: " + chave + ", Valor: " + valor);
        RESULT = map;
    :}
;

// Chave valor recursivo, armazenando um array de hashmaps ou nao
chaves_valor ::= chave_valor:cv
    {: 
        System.out.println("Chave: " + cv.keySet().toArray()[0] + ", Valor: " + cv.values().toArray()[0]);
        List<HashMap<String, String>> list = new ArrayList<>();
        list.add(cv);
        RESULT = list;
    :}
    | chaves_valor:cv chave_valor:cv2
    {: 
        System.out.println("Chave: " + cv2.keySet().toArray()[0] + ", Valor: " + cv2.values().toArray()[0]);
        List<HashMap<String, String>> list = new ArrayList<>();
        list.addAll(cv);
        list.add(cv2);
        RESULT = list;
    :}
;
